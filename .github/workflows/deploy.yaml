name: Deploy AKS Kafka Postgres App with Istio + Cloudflare + TLS

on:
  push:
    branches: [ main ]

env:
  TF_DIR: ./terraform
  K8S_DIR: ./k8s
  ACR_NAME: aiinfraacr2901
  ACR_LOGIN_SERVER: aiinfraacr2901.azurecr.io

  # ARM credentials
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

  # Cloudflare
  CF_ZONE_ID: ${{ secrets.CF_ZONE_ID }}
  CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}

  # Istio mode: "sidecar" or "ambient"
  ISTIO_MODE: "sidecar"

jobs:
  build-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    # --- Terraform ---
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Terraform Init
      working-directory: ${{ env.TF_DIR }}
      run: terraform init

    - name: Terraform Apply
      working-directory: ${{ env.TF_DIR }}
      run: terraform apply -auto-approve

    # --- kubectl ---
    - name: Setup kubectl
      uses: azure/setup-kubectl@v4

    - name: Get AKS Credentials
      run: |
        az login --service-principal \
          --username $ARM_CLIENT_ID \
          --password $ARM_CLIENT_SECRET \
          --tenant $ARM_TENANT_ID
        az aks get-credentials \
          --resource-group rg-kafka-postgres-demo \
          --name aks-kafka-postgres \
          --overwrite-existing

    # --- ACR ---
    - name: ACR Login
      run: az acr login --name $ACR_NAME

    - name: Build & Push Images
      run: |
        set -e
        for svc in order-api payment-service inventory-service notification-service analytics-service; do
          docker build -t $ACR_LOGIN_SERVER/$svc:latest ./services/$svc
          docker push $ACR_LOGIN_SERVER/$svc:latest
        done

    # --- Istio ---
    - name: Install Istio
      run: |
        curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.22.0 sh -
        export PATH=$PWD/istio-1.22.0/bin:$PATH

        kubectl create namespace kafka --dry-run=client -o yaml | kubectl apply -f -
        kubectl create namespace postgres --dry-run=client -o yaml | kubectl apply -f -

        if [ "${{ env.ISTIO_MODE }}" = "ambient" ]; then
          istioctl install --set profile=ambient -y
          kubectl label namespace default istio.io/dataplane-mode=ambient --overwrite
          kubectl label namespace kafka istio.io/dataplane-mode=ambient --overwrite
          kubectl label namespace postgres istio.io/dataplane-mode=ambient --overwrite
        else
          istioctl install --set profile=demo -y
          kubectl label namespace default istio-injection=enabled --overwrite
          kubectl label namespace kafka istio-injection=enabled --overwrite
          kubectl label namespace postgres istio-injection=enabled --overwrite
        fi

    # --- cert-manager ---
    - name: Install cert-manager
      run: |
        kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
        kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml

        kubectl rollout status deployment/cert-manager -n cert-manager --timeout=300s
        kubectl rollout status deployment/cert-manager-cainjector -n cert-manager --timeout=300s
        kubectl rollout status deployment/cert-manager-webhook -n cert-manager --timeout=300s

        kubectl create secret generic cloudflare-api-token-secret \
          --from-literal=api-token=${{ secrets.CF_API_TOKEN }} \
          -n cert-manager --dry-run=client -o yaml | kubectl apply -f -

        kubectl apply -f k8s/cert-manager/cluster-issuer.yaml
        kubectl apply -f k8s/cert-manager/wildcard-certificate.yaml

    - name: Wait for cert-manager + DNS propagation
      run: |
        echo "Sleeping 90s to allow DNS + cert-manager validation..."
        sleep 90

    # --- Kafka Operator ---
    - name: Install Strimzi (Kafka Operator)
      run: |
        kubectl apply -f "https://strimzi.io/install/latest?namespace=kafka" -n kafka
        kubectl wait --for=condition=Established crd/kafkas.kafka.strimzi.io --timeout=180s
        kubectl rollout status deployment/strimzi-cluster-operator -n kafka --timeout=300s

    # --- Postgres Operator ---
    - name: Install Zalando Postgres Operator
      run: |
        VERSION=v1.10.1
        kubectl apply -f https://raw.githubusercontent.com/zalando/postgres-operator/$VERSION/manifests/postgresql.crd.yaml
        kubectl apply -n postgres -f https://raw.githubusercontent.com/zalando/postgres-operator/$VERSION/manifests/configmap.yaml
        curl -s -o operator-rbac.yaml https://raw.githubusercontent.com/zalando/postgres-operator/$VERSION/manifests/operator-service-account-rbac.yaml
        sed -i 's/namespace: default/namespace: postgres/' operator-rbac.yaml
        kubectl apply -f operator-rbac.yaml
        kubectl apply -n postgres -f https://raw.githubusercontent.com/zalando/postgres-operator/$VERSION/manifests/postgres-operator.yaml
        kubectl apply -n postgres -f https://raw.githubusercontent.com/zalando/postgres-operator/$VERSION/manifests/api-service.yaml
        kubectl wait --for=condition=Established crd/postgresqls.acid.zalan.do --timeout=180s
        kubectl rollout status deployment/postgres-operator -n postgres --timeout=300s

    # --- Deploy Clusters ---
    - name: Deploy Kafka & Postgres clusters
      run: |
        kubectl apply -f $K8S_DIR/kafka/kafka-cluster.yaml -n kafka
        kubectl apply -f $K8S_DIR/kafka/kafka-topics.yaml -n kafka

        # apply Postgres DBs for each microservice
        kubectl apply -f $K8S_DIR/postgres/orders-db.yaml -n postgres
        kubectl apply -f $K8S_DIR/postgres/payments-db.yaml -n postgres
        kubectl apply -f $K8S_DIR/postgres/inventory-db.yaml -n postgres
        kubectl apply -f $K8S_DIR/postgres/notifications-db.yaml -n postgres
        kubectl apply -f $K8S_DIR/postgres/analytics-db.yaml -n postgres

    - name: Wait for Postgres DB reconciliation
      run: |
        echo "Sleeping 90s to allow Postgres operator to create DBs + secrets..."
        sleep 90

    # --- Sync DB Secrets into default namespace ---
    - name: Sync Postgres Secrets
      run: |
        declare -A DBS=(
          ["orders-db"]="ordersdb"
          ["payments-db"]="paymentsdb"
          ["inventory-db"]="inventorydb"
          ["notifications-db"]="notificationsdb"
          ["analytics-db"]="analyticsdb"
        )

        for db in "${!DBS[@]}"; do
          user="${db%%-*}_user"
          secret_name="${user}.${db}.credentials.postgresql.acid.zalan.do"

          echo "ðŸ”¹ Syncing credentials for $db ($user)"

          kubectl create secret generic ${db}-credentials \
            -n default \
            --from-literal=username=$(kubectl get secret $secret_name -n postgres -o jsonpath='{.data.username}' | base64 -d) \
            --from-literal=password=$(kubectl get secret $secret_name -n postgres -o jsonpath='{.data.password}' | base64 -d) \
            --from-literal=host=${db}.postgres.svc.cluster.local \
            --from-literal=port=5432 \
            --from-literal=dbname=${DBS[$db]} \
            --dry-run=client -o yaml | kubectl apply -f -
        done

    # --- Deploy Microservices ---
    - name: Deploy Microservices + Istio Gateway
      run: |
        kubectl apply -f $K8S_DIR/apps/configmap.yaml
        kubectl apply -f $K8S_DIR/apps/secrets.yaml
        kubectl apply -f $K8S_DIR/apps/
        kubectl apply -f $K8S_DIR/apps/gateway.yaml
        kubectl apply -f $K8S_DIR/apps/virtualservices.yaml
