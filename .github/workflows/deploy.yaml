name: Deploy AKS Kafka Postgres App with Istio + Cloudflare + TLS

on:
  push:
    branches: [ main ]

env:
  TF_DIR: ./terraform
  K8S_DIR: ./k8s
  ACR_NAME: aiinfraacr2901
  ACR_LOGIN_SERVER: aiinfraacr2901.azurecr.io

  # ARM credentials
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

  # Cloudflare
  CF_ZONE_ID: ${{ secrets.CF_ZONE_ID }}
  CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}

  # Istio mode: "sidecar" or "ambient"
  ISTIO_MODE: "sidecar"

jobs:
  build-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    # --- Terraform ---
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Terraform Init
      working-directory: ${{ env.TF_DIR }}
      run: terraform init

    - name: Terraform Apply
      working-directory: ${{ env.TF_DIR }}
      run: terraform apply -auto-approve

    # --- kubectl ---
    - name: Setup kubectl
      uses: azure/setup-kubectl@v4

    - name: Get AKS Credentials
      run: |
        az login --service-principal \
          --username $ARM_CLIENT_ID \
          --password $ARM_CLIENT_SECRET \
          --tenant $ARM_TENANT_ID
        az aks get-credentials \
          --resource-group rg-kafka-postgres-demo \
          --name aks-kafka-postgres \
          --overwrite-existing

    # --- ACR ---
    - name: ACR Login
      run: az acr login --name $ACR_NAME

    - name: Build & Push Images
      run: |
        set -e
        for svc in order-api payment-service inventory-service notification-service analytics-service; do
          docker build -t $ACR_LOGIN_SERVER/$svc:latest ./services/$svc
          docker push $ACR_LOGIN_SERVER/$svc:latest
        done

    # --- Istio ---
    - name: Install Istio
      run: |
        curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.22.0 sh -
        export PATH=$PWD/istio-1.22.0/bin:$PATH

        kubectl create namespace kafka --dry-run=client -o yaml | kubectl apply -f -
        kubectl create namespace postgres --dry-run=client -o yaml | kubectl apply -f -

        if [ "${{ env.ISTIO_MODE }}" = "ambient" ]; then
          istioctl install --set profile=ambient -y
          kubectl label namespace default istio.io/dataplane-mode=ambient --overwrite
          kubectl label namespace kafka istio.io/dataplane-mode=ambient --overwrite
          kubectl label namespace postgres istio.io/dataplane-mode=ambient --overwrite
        else
          istioctl install --set profile=demo -y
          kubectl label namespace default istio-injection=enabled --overwrite
          kubectl label namespace kafka istio-injection=enabled --overwrite
          kubectl label namespace postgres istio-injection=enabled --overwrite
        fi

    # --- cert-manager ---
    - name: Install cert-manager
      run: |
        kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
        kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml

        kubectl rollout status deployment/cert-manager -n cert-manager --timeout=300s
        kubectl rollout status deployment/cert-manager-cainjector -n cert-manager --timeout=300s
        kubectl rollout status deployment/cert-manager-webhook -n cert-manager --timeout=300s

        kubectl create secret generic cloudflare-api-token-secret \
          --from-literal=api-token=${{ secrets.CF_API_TOKEN }} \
          -n cert-manager --dry-run=client -o yaml | kubectl apply -f -

        kubectl apply -f k8s/cert-manager/cluster-issuer.yaml
        kubectl apply -f k8s/cert-manager/wildcard-certificate.yaml

    - name: Wait for cert-manager + DNS propagation
      run: |
        echo "Sleeping 90s to allow DNS + cert-manager validation..."
        sleep 90

    # --- Kafka Operator ---
    - name: Install Strimzi (Kafka Operator)
      run: |
        kubectl apply -f "https://strimzi.io/install/latest?namespace=kafka" -n kafka
        kubectl wait --for=condition=Established crd/kafkas.kafka.strimzi.io --timeout=180s
        kubectl rollout status deployment/strimzi-cluster-operator -n kafka --timeout=300s

    # --- Postgres Operator ---
    - name: Install Zalando Postgres Operator
      run: |
        VERSION=v1.10.1
        kubectl apply -f https://raw.githubusercontent.com/zalando/postgres-operator/$VERSION/manifests/postgresql.crd.yaml
        kubectl apply -n postgres -f https://raw.githubusercontent.com/zalando/postgres-operator/$VERSION/manifests/configmap.yaml
        curl -s -o operator-rbac.yaml https://raw.githubusercontent.com/zalando/postgres-operator/$VERSION/manifests/operator-service-account-rbac.yaml
        sed -i 's/namespace: default/namespace: postgres/' operator-rbac.yaml
        kubectl apply -f operator-rbac.yaml
        kubectl apply -n postgres -f https://raw.githubusercontent.com/zalando/postgres-operator/$VERSION/manifests/postgres-operator.yaml
        kubectl apply -n postgres -f https://raw.githubusercontent.com/zalando/postgres-operator/$VERSION/manifests/api-service.yaml
        kubectl wait --for=condition=Established crd/postgresqls.acid.zalan.do --timeout=180s
        kubectl rollout status deployment/postgres-operator -n postgres --timeout=300s

    # --- Deploy Clusters ---
    - name: Deploy Kafka & Postgres clusters
      run: |
        kubectl apply -f $K8S_DIR/kafka/kafka-cluster.yaml -n kafka
        kubectl apply -f $K8S_DIR/kafka/kafka-topics.yaml -n kafka

        # apply Postgres DBs for each microservice
        kubectl apply -f $K8S_DIR/postgres/orders-db.yaml -n postgres
        kubectl apply -f $K8S_DIR/postgres/payments-db.yaml -n postgres
        kubectl apply -f $K8S_DIR/postgres/inventory-db.yaml -n postgres
        kubectl apply -f $K8S_DIR/postgres/notifications-db.yaml -n postgres
        kubectl apply -f $K8S_DIR/postgres/analytics-db.yaml -n postgres

    - name: Wait for Postgres DB reconciliation
      run: |
        echo "Sleeping 90s to allow Postgres operator to create DBs + secrets..."
        sleep 90

    # --- Sync Secrets into default namespace ---
    - name: Sync Postgres secrets into default namespace
      run: |
        for svc in orders payments inventory notifications analytics; do
          secret_name="${svc}-user.${svc}-db.credentials.postgresql.acid.zalan.do"
          echo "Syncing $secret_name from postgres -> default"
          kubectl get secret $secret_name -n postgres -o yaml \
            | sed 's/namespace: postgres/namespace: default/' \
            | kubectl apply -f -
        done

    # --- Deploy Microservices ---
    - name: Deploy Microservices + Istio Gateway
      run: |
        kubectl apply -f $K8S_DIR/apps/configmap.yaml
        kubectl apply -f $K8S_DIR/apps/secrets.yaml
        kubectl apply -f $K8S_DIR/apps/
        kubectl apply -f $K8S_DIR/apps/gateway.yaml
        kubectl apply -f $K8S_DIR/apps/virtualservices.yaml

    # --- Istio Ingress ---
    - name: Get Istio Ingress IP
      id: istioip
      run: |
        IP=""
        for i in {1..30}; do
          IP=$(kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -n "$IP" ]; then break; fi
          echo "Waiting for Istio ingress IP..."
          sleep 10
        done
        echo "ISTIO_IP=$IP" >> $GITHUB_ENV
        echo "Istio ingress IP is $IP"

    # --- Cloudflare DNS ---
    - name: Update Cloudflare DNS
      run: |
        for sub in orders payments inventory notifications analytics; do
          echo "Creating new record for $sub.parallelservicesllc.com"
          curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${CF_ZONE_ID}/dns_records" \
          -H "Authorization: Bearer ${CF_API_TOKEN}" \
          -H "Content-Type: application/json" \
          --data "{
            \"type\":\"A\",
            \"name\":\"$sub.parallelservicesllc.com\",
            \"content\":\"$ISTIO_IP\",
            \"ttl\":120,
            \"proxied\":false
          }" | jq .
        done

    - name: Wait for Cloudflare DNS propagation
      run: |
        echo "Sleeping 60s to allow Cloudflare DNS to propagate..."
        sleep 60

    - name: Inject Cloudflare API Token Secret for cert-manager
      run: |
        kubectl create secret generic cloudflare-api-token-secret \
          --from-literal=api-token=${{ secrets.CF_API_TOKEN }} \
          -n cert-manager --dry-run=client -o yaml | kubectl apply -f -
